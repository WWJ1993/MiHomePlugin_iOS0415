{"version":3,"sources":["../../src/data/resolve.js"],"names":[],"mappings":"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","file":"resolve.js","sourcesContent":["const invariant = require(\"invariant\");\n\nconst findContentsUniq = require(\"./findContentsUniq\");\nconst findChildrenDuplicates = require(\"./findChildrenDuplicates\");\nconst TextureObjects = require(\"./TextureObjects\");\nconst extractImages = require(\"./extractImages\");\nconst uniqImages = require(\"./uniqImages\");\n\n///// resolve: takes the output of fill(build(*)) to generate the final data tree\n// The algorithm simplifies the data tree to use shared framebuffers if some VDOM is duplicated in the tree (e.g: content / GL.Node)\n\nfunction resolve (dataTree) {\n  let imagesToPreload = [];\n\n  // contents are view/canvas/image/video to be rasterized \"globally\"\n  const contentsMeta = findContentsUniq(dataTree);\n  const contentsVDOM = contentsMeta.map(({vdom}) => vdom);\n\n  // Recursively \"resolve\" the data to assign fboId and factorize duplicate uniforms to shared uniforms.\n  function resolveRec (data, fboId, parentContext, parentFbos) {\n    const { uniforms: dataUniforms, children: dataChildren, contents: dataContents, preload, ...dataRest } = data;\n    const uniforms = {...dataUniforms};\n    const parentContextVDOM = parentContext.map(({vdom}) => vdom);\n\n    // A function to generate a free FBO id for this node\n    const genFboId = (fboIdCounter =>\n      () => {\n        fboIdCounter ++;\n        while (\n          fboIdCounter === fboId || // fbo should not take the current one\n          parentFbos.indexOf(fboIdCounter)!==-1) // ensure fbo is not already taken in parents\n          fboIdCounter ++;\n        return fboIdCounter;\n      }\n    )(-1);\n\n    // shared contains all nodes that are contains in more than one direct children.\n    const shared = findChildrenDuplicates(data, parentContextVDOM);\n\n    // We assign fboIds to shared\n    const childrenContext = shared.map(({vdom}) => {\n      const fboId = genFboId();\n      return { vdom, fboId };\n    });\n\n    // We accumulate into context the childrenContext and the parentContext\n    const context = parentContext.concat(childrenContext);\n    const contextVDOM = context.map(({vdom}) => vdom);\n    const contextFbos = context.map(({fboId}) => fboId);\n\n    // contextChildren and children are field to fill for this node\n    // We traverse the dataChildren to resolve where each child should go:\n    // either we create a new child, a we create context child or we use an existing parent context\n    const contextChildren = [];\n    const children = [];\n\n    const toRecord = dataChildren.concat(shared).map(child => {\n      const { uniform, vdom, data } = child;\n      let i = contextVDOM.indexOf(vdom);\n      let fboId, addToCollection;\n      if (i===-1) {\n        fboId = genFboId();\n        addToCollection = children;\n      }\n      else {\n        fboId = context[i].fboId;\n        if (i >= parentContext.length) {// is a new context children\n          addToCollection = contextChildren;\n        }\n      }\n      if (uniform) uniforms[uniform] = TextureObjects.Framebuffer(fboId);\n      return { data, fboId, addToCollection };\n    });\n\n    const childrenFbos = toRecord.map(({fboId})=>fboId);\n    const allFbos = parentFbos.concat(contextFbos).concat(childrenFbos);\n\n    const recorded = [];\n    toRecord.forEach(({ data, fboId, addToCollection }) => {\n      if (recorded.indexOf(fboId) === -1) {\n        recorded.push(fboId);\n        if (addToCollection) addToCollection.unshift(resolveRec(data, fboId, context, allFbos));\n      }\n    });\n\n    dataContents.forEach(({ uniform, vdom, opts }) => {\n      const id = contentsVDOM.indexOf(vdom);\n      invariant(id!==-1, \"contents was discovered by findContentsMeta\");\n      uniforms[uniform] = TextureObjects.withOpts(TextureObjects.Content(id), opts);\n    });\n\n    // Check images to preload\n    if (preload) {\n      imagesToPreload = imagesToPreload.concat(extractImages(dataUniforms));\n    }\n\n    return {\n      ...dataRest, // eslint-disable-line no-undef\n      uniforms,\n      contextChildren,\n      children,\n      fboId\n    };\n  }\n\n  return {\n    data: resolveRec(dataTree, -1, [], []),\n    contentsVDOM,\n    imagesToPreload: uniqImages(imagesToPreload)\n  };\n}\n\nmodule.exports = resolve;\n"]}