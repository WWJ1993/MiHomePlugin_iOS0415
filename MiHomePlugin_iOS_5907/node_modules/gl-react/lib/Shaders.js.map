{"version":3,"sources":["../src/Shaders.js"],"names":[],"mappings":";;;;;;AAAA,IAAM,YAAY,QAAQ,WAAR,CAAZ;AACN,IAAM,QAAQ,QAAQ,eAAR,CAAR;;AAEN,IAAM,cAAc,UAAd;;AAEN,IAAI,OAAO,CAAP;AACJ,IAAM,QAAQ,EAAR;AACN,IAAM,UAAU,EAAV;AACN,IAAM,0BAA0B,EAA1B;AACN,IAAM,wBAAwB,EAAxB;AACN,IAAM,2BAA2B,EAA3B;;AAEN,IAAM,iBAAiB,EAAjB;AACN,IAAM,yBAAyB,EAAzB;;AAEN,IAAI,YAAY,OAAZ;AACJ,IAAM,iBAAiB,UAAU,OAAV;;AAEvB,IAAM,MAAM,SAAN,GAAM,SAAU;AACpB,MAAM,aAAa,aAAa,OAAb,EAAsB,MAAtB,CAAb,CADc;AAEpB,MAAM,KAAK,cAAc,MAAd,CAFS;AAGpB,MAAI,gBAAJ,CAHoB;AAIpB,MAAI,CAAC,UAAD,EAAa;AACf,UAAM,EAAN,IAAY,OAAO,IAAP,CADG;AAEf,YAAQ,EAAR,IAAc,MAAd,CAFe;AAGf,6BAAyB,EAAzB,IAA+B,CAA/B,CAHe;AAIf,4BAAwB,EAAxB,IAA8B,UAC9B,eACG,IADH,CACQ;aAAQ,KAAK,GAAL,CAAS,EAAT,EAAa,MAAb;KAAR,CADR,CAEG,IAFH,CAEQ;aAAU,sBAAsB,EAAtB,IAA4B,MAA5B;KAAV,CAHsB,CAJf;GAAjB,MASK;AACH,cAAU,wBAAwB,EAAxB,CAAV,CADG;GATL;AAYA,SAAO,EAAE,MAAF,EAAM,gBAAN,EAAP,CAhBoB;CAAV;;AAmBZ,IAAM,SAAS,SAAT,MAAS,KAAM;AACnB,SAAO,QAAQ,EAAR,CAAP,CADmB;AAEnB,SAAO,MAAM,EAAN,CAAP,CAFmB;AAGnB,SAAO,yBAAyB,EAAzB,CAAP,CAHmB;AAInB,SAAO,wBAAwB,EAAxB,CAAP,CAJmB;AAKnB,iBAAe,IAAf,CAAoB;WAAQ,KAAK,MAAL,CAAY,EAAZ;GAAR,CAApB,CALmB;CAAN;;AAQf,IAAM,qBAAqB,SAArB,kBAAqB;SACzB,OAAO,IAAP,CAAY,wBAAZ,EACC,MADD,CACQ;WAAM,yBAAyB,EAAzB,KAAgC,CAAhC;GAAN,CADR,CAEC,GAFD,CAEK;WAAM,SAAS,EAAT,EAAa,EAAb;GAAN;CAHoB;;AAK3B,IAAI,kBAAJ;AACA,IAAM,QAAQ,SAAR,KAAQ,GAAM;AAClB,eAAa,SAAb,EADkB;AAElB,uBAAqB,OAArB,CAA6B,MAA7B,EAFkB;CAAN;AAId,IAAM,aAAa,SAAb,UAAa,GAAM;;;AAGvB,MAAM,aAAa,qBAAqB,MAArB,GAA8B,EAA9B,CAHI;AAIvB,MAAI,CAAC,UAAD,EAAa,aAAa,SAAb,EAAjB;AACA,cAAY,WAAW,KAAX,EAAkB,GAAlB,CAAZ,CALuB;CAAN;;AAQnB,IAAM,aAAa,SAAb,UAAa,CAAC,CAAD,EAAI,CAAJ;SAAU,EAAE,IAAF,KAAW,EAAE,IAAF;CAArB;;AAEnB,IAAM,eAAe,SAAf,YAAe,CAAC,OAAD,EAAU,MAAV,EAAqB;AACxC,OAAK,IAAI,EAAJ,IAAU,OAAf,EAAwB;AACtB,QAAI,WAAW,QAAQ,EAAR,CAAX,EAAwB,MAAxB,CAAJ,EAAqC;AACnC,aAAO,SAAS,EAAT,EAAa,EAAb,CAAP,CADmC;KAArC;GADF;AAKA,SAAO,IAAP,CANwC;CAArB;;AASrB,IAAM,WAAW,SAAX,QAAW;SAAU;WACzB,QAAQ,KAAR;AACE,iBAAa,OAAO,IAAP,GAAc,wBAA3B,GAAsD,KAAtD;GAFuB;CAAV;;AAKjB,IAAM,UAAU;AAEd,oDAAqB,WAAW;AAC9B,mBAAe,SAAf,IAA4B,EAA5B,CAD8B;GAFlB;AAMd,wDAAuB,WAAW;AAChC,mBAAe,SAAf,EAA0B,OAA1B,CAAkC;aAChC,yBAAyB,EAAzB;KADgC,CAAlC,CADgC;AAGhC,WAAO,eAAe,SAAf,CAAP,CAHgC;AAIhC,WAAO,uBAAuB,SAAvB,CAAP,CAJgC;AAKhC,iBALgC;GANpB;AAcd,oDAAqB,WAAW;AAC9B,2BAAuB,SAAvB,IAAoC,eAAe,SAAf,CAApC,CAD8B;AAE9B,mBAAe,SAAf,IAA4B,EAA5B,CAF8B;GAdlB;;;;;AAqBd,8BAAU,YAAY,WAAW,gBAAgB;AAC/C,QAAI,OAAO,UAAP,KAAsB,QAAtB,EAAgC,OAAO,UAAP,CAApC;;eACwB,eAAM,MAAM,WAAN,IAAsB,WAA5B,EAFuB;;QAEvC,aAFuC;QAEnC,uBAFmC;;AAG/C,QAAI,cAAJ,EAAoB;AAClB,cAAQ,IAAR,CACE;eAAU,eAAe,IAAf,EAAqB,MAArB;OAAV,EACA;eAAS,eAAe,KAAf;OAAT,CAFF,CADkB;KAApB,MAKK;AACH,cAAQ,KAAR,CAAc,SAAS,QAAQ,GAAR,CAAY,EAAZ,CAAT,CAAd,EADG;KALL;AAQA,QAAM,UAAU,eAAe,SAAf,CAAV,CAXyC;AAY/C,YAAQ,IAAR,CAAa,EAAb,EAZ+C;AAa/C,WAAO,EAAP,CAb+C;GArBnC;AAqCd,kDAAoB,WAAW;AAC7B,2BAAuB,SAAvB,EAAkC,OAAlC,CAA0C;aACxC,yBAAyB,EAAzB;KADwC,CAA1C,CAD6B;AAG7B,mBAAe,SAAf,EAA0B,OAA1B,CAAkC;aAChC,yBAAyB,EAAzB;KADgC,CAAlC,CAH6B;AAK7B,WAAO,uBAAuB,SAAvB,CAAP,CAL6B;AAM7B,iBAN6B;GArCjB;;;;;;AAiDd,0BAAQ,KAAK,cAAc;AACzB,cAAU,QAAO,iDAAP,KAAe,QAAf,EAAyB,0BAAnC,EADyB;AAEzB,QAAM,SAAS,EAAT,CAFmB;AAGzB,QAAM,gBAAgB,EAAhB;QAAoB,iBAAiB,EAAjB,CAHD;AAIzB,YAAQ,GAAR,CAAY,OAAO,IAAP,CAAY,GAAZ,EAAiB,GAAjB,CAAqB,eAAO;AACtC,UAAM,SAAS,IAAI,GAAJ,CAAT,CADgC;AAEtC,gBAAU,QAAO,uDAAP,KAAkB,QAAlB,IAA8B,OAAO,OAAO,IAAP,KAAgB,QAAvB,EACxC,gFADA,EAFsC;;kBAIhB,eAAM,MAAM,GAAN,IAAc,OAApB,EAJgB;;UAI/B,cAJ+B;UAI3B,wBAJ2B;;AAKtC,aAAO,GAAP,IAAc,EAAd,CALsC;AAMtC,+BAAyB,EAAzB,IANsC;AAOtC,aAAO,QAAQ,IAAR,CACL;eAAU,eAAe,GAAf,IAAsB,MAAtB;OAAV,EACA;eAAS,cAAc,GAAd,IAAqB,KAArB;OAAT,CAFF,CAPsC;KAAP,CAAjC,EAYC,IAZD,CAYM,YAAM;AACV,UAAI,YAAJ,EAAkB;AAChB,qBACE,OAAO,IAAP,CAAY,aAAZ,EAA2B,MAA3B,GAAoC,aAApC,GAAoD,IAApD,EACA,cAFF,EADgB;OAAlB,MAKK;AACH,eAAO,IAAP,CAAY,aAAZ,EAA2B,OAA3B,CAAmC;iBACjC,SAAS,QAAQ,GAAR,CAAY,OAAO,GAAP,CAAZ,CAAT,EAAmC,cAAc,GAAd,CAAnC;SADiC,CAAnC,CADG;OALL;KADI,CAZN,CAJyB;AA2BzB,WAAO,MAAP,CA3ByB;GAjDb;;;;AAgFd,oBAAK,IAAI;AACP,WAAO,OAAO,MAAP,CAAc,QAAQ,EAAR,CAAd,CAAP,CADO;GAhFK;;;;;AAsFd,sDAAsB,IAAI;AACxB,WAAO,sBAAsB,EAAtB,KAA6B,IAA7B,CADiB;GAtFZ;;;;;;AA6Fd,wDAAuB,IAAI;AACzB,WAAO,wBAAwB,EAAxB,KAA+B,IAA/B,CADkB;GA7Fb;;;;AAkGd,wBAAQ;AACN,WAAO,OAAO,IAAP,CAAY,OAAZ,CAAP,CADM;GAlGM;;;;AAuGd,0BAAQ,IAAI;AACV,WAAO,MAAM,OAAN,CADG;GAvGE;;;AA2Gd,cA3Gc;;AA6Gd,qBAAmB,iCAAQ;AACzB,cAAU,SAAV,EAAqB,mDAArB,EADyB;AAEzB,cAAU,OAAV,CAAkB,IAAlB,EAFyB;AAGzB,gBAAY,IAAZ,CAHyB;GAAR;;AAMnB,gCAnHc;CAAV;;AAsHN,OAAO,OAAP,GAAiB,OAAO,MAAP,CAAc,OAAd,CAAjB","file":"Shaders.js","sourcesContent":["const invariant = require(\"invariant\");\nconst defer = require(\"promise-defer\");\n\nconst INLINE_NAME = \"<inline>\";\n\nlet _uid = 1;\nconst names = {}; // keep names\nconst shaders = {}; // keep shader objects\nconst shadersCompileResponses = {}; // keep promise of compile responses\nconst shadersCompileResults = {}; // keep only the successful result\nconst shadersReferenceCounters = {}; // reference count the shaders created with Shaders.create()/used inline so we don't delete them if one of 2 dups is still used\n\nconst surfaceInlines = {};\nconst previousSurfaceInlines = {};\n\nlet implDefer = defer();\nconst implementation = implDefer.promise;\n\nconst add = shader => {\n  const existingId = findShaderId(shaders, shader);\n  const id = existingId || _uid ++;\n  let promise;\n  if (!existingId) {\n    names[id] = shader.name;\n    shaders[id] = shader;\n    shadersReferenceCounters[id] = 0;\n    shadersCompileResponses[id] = promise =\n    implementation\n      .then(impl => impl.add(id, shader))\n      .then(result => shadersCompileResults[id] = result);\n  }\n  else {\n    promise = shadersCompileResponses[id];\n  }\n  return { id, promise };\n};\n\nconst remove = id => {\n  delete shaders[id];\n  delete names[id];\n  delete shadersReferenceCounters[id];\n  delete shadersCompileResponses[id];\n  implementation.then(impl => impl.remove(id));\n};\n\nconst getShadersToRemove = () =>\n  Object.keys(shadersReferenceCounters)\n  .filter(id => shadersReferenceCounters[id] <= 0)\n  .map(id => parseInt(id, 10));\n\nlet scheduled;\nconst gcNow = () => {\n  clearTimeout(scheduled);\n  getShadersToRemove().forEach(remove);\n};\nconst scheduleGC = () => {\n  // debounce the shader deletion to let a last chance to a future dup shader to appear\n  // the idea is also to postpone this operation when the app is not so busy\n  const noDebounce = getShadersToRemove().length > 20;\n  if (!noDebounce) clearTimeout(scheduled);\n  scheduled = setTimeout(gcNow, 500);\n};\n\nconst sameShader = (a, b) => a.frag === b.frag;\n\nconst findShaderId = (shaders, shader) => {\n  for (let id in shaders) {\n    if (sameShader(shaders[id], shader)) {\n      return parseInt(id, 10);\n    }\n  }\n  return null;\n};\n\nconst logError = shader => error =>\n  console.error( //eslint-disable-line no-console\n    \"Shader '\" + shader.name + \"' failed to compile:\\n\" + error\n  );\n\nconst Shaders = {\n\n  _onSurfaceWillMount (surfaceId) {\n    surfaceInlines[surfaceId] = [];\n  },\n\n  _onSurfaceWillUnmount (surfaceId) {\n    surfaceInlines[surfaceId].forEach(id =>\n      shadersReferenceCounters[id]--);\n    delete surfaceInlines[surfaceId];\n    delete previousSurfaceInlines[surfaceId];\n    scheduleGC();\n  },\n\n  _beforeSurfaceBuild (surfaceId) {\n    previousSurfaceInlines[surfaceId] = surfaceInlines[surfaceId];\n    surfaceInlines[surfaceId] = [];\n  },\n\n  // Resolve the shader field of GL.Node.\n  // it can be an id (created with Shaders.create) or an inline object.\n  _resolve (idOrObject, surfaceId, compileHandler) {\n    if (typeof idOrObject === \"number\") return idOrObject;\n    const { id, promise } = add({ name: INLINE_NAME, ...idOrObject });\n    if (compileHandler) {\n      promise.then(\n        result => compileHandler(null, result),\n        error => compileHandler(error));\n    }\n    else {\n      promise.catch(logError(Shaders.get(id)));\n    }\n    const inlines = surfaceInlines[surfaceId];\n    inlines.push(id);\n    return id;\n  },\n\n  _afterSurfaceBuild (surfaceId) {\n    previousSurfaceInlines[surfaceId].forEach(id =>\n      shadersReferenceCounters[id]--);\n    surfaceInlines[surfaceId].forEach(id =>\n      shadersReferenceCounters[id]++);\n    delete previousSurfaceInlines[surfaceId];\n    scheduleGC();\n  },\n\n  //~~~ Exposed methods ~~~ //\n\n  // Create shaders statically\n  create (obj, onAllCompile) {\n    invariant(typeof obj === \"object\", \"config must be an object\");\n    const result = {};\n    const compileErrors = {}, compileResults = {};\n    Promise.all(Object.keys(obj).map(key => {\n      const shader = obj[key];\n      invariant(typeof shader === \"object\" && typeof shader.frag === \"string\",\n      \"invalid shader given to Shaders.create(). A valid shader is a { frag: String }\");\n      const {id, promise} = add({ name: key, ...shader });\n      result[key] = id;\n      shadersReferenceCounters[id] ++;\n      return promise.then(\n        result => compileResults[key] = result,\n        error => compileErrors[key] = error\n      );\n    }))\n    .then(() => {\n      if (onAllCompile) {\n        onAllCompile(\n          Object.keys(compileErrors).length ? compileErrors : null,\n          compileResults);\n      }\n      else {\n        Object.keys(compileErrors).forEach(key =>\n          logError(Shaders.get(result[key]))(compileErrors[key]));\n      }\n    });\n    return result;\n  },\n\n  // Get the shader object by id.\n  get (id) {\n    return Object.freeze(shaders[id]);\n  },\n\n  // Synchronously retrieve the successful compilation response.\n  // returns or ShaderResult object or null if there were a failure or not ready\n  getCompilationResult (id) {\n    return shadersCompileResults[id] || null;\n  },\n\n  // Get the promise of the compilation state. Allows you to wait for compilation\n  // and also map on errors.\n  // Returns null only if you never have created this shader.\n  getCompilationPromise (id) {\n    return shadersCompileResponses[id] || null;\n  },\n\n  // List all shader ids that exists at the moment.\n  list () {\n    return Object.keys(shaders);\n  },\n\n  // Check if a shader exists\n  exists (id) {\n    return id in shaders;\n  },\n\n  gcNow,\n\n  setImplementation: impl => {\n    invariant(implDefer, \"Shaders.setImplementation can be called only once\");\n    implDefer.resolve(impl);\n    implDefer = null;\n  },\n\n  implementation\n};\n\nmodule.exports = Object.freeze(Shaders);\n"]}